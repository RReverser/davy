!function(e){"use strict";function t(e){this.value=e,this.deferreds=[]}function i(e,t,i){l(function(){var r,s=e[t],l=e.promise;if(f(s)){try{r=s(i)}catch(o){return l.reject(o),void 0}l.fulfill(r)}else l[t](i)})}function r(e,t,i){return{promise:e,fulfill:t,reject:i}}function s(e){return e&&"object"==typeof e}function f(e){return e&&"function"==typeof e}if("function"==typeof define&&define.amd)define(t);else if("object"==typeof module&&module.exports){module.exports=t;var l=require("subsequent")}else{e.Troth=e.Promise=t;var l=e.nextTick}t.SUCCESS="fulfill",t.FAILURE="reject",t.prototype.isFulfilled=!1,t.prototype.isRejected=!1,t.prototype.then=function(e,s){var f=new t,l=r(f,e,s);return this.isFulfilled||this.isRejected?i(l,this.isFulfilled?t.SUCCESS:t.FAILURE,this.value):this.deferreds.push(l),f},t.prototype.fulfill=function(e){if(!this.isFulfilled&&!this.isRejected)try{if(e===this)throw new TypeError("Can't resolve a promise with itself.");if(s(e)||f(e)){var t=e.then,i=this;if(f(t))return t.call(e,function(e){i.fulfill(e)},function(e){i.reject(e)}),void 0}this.isFulfilled=!0,this.complete(e)}catch(r){this.reject(r)}},t.prototype.reject=function(e){this.isFulfilled||this.isRejected||(this.isRejected=!0,this.complete(e))},t.prototype.complete=function(e){this.value=e;for(var r=this.isFulfilled?t.SUCCESS:t.FAILURE,s=0;s<this.deferreds.length;++s)i(this.deferreds[s],r,e);this.deferreds=void 0}}(this);
//# sourceMappingURL=troth.min.js.map